/**
 * MessagePack fetch utilities
 * All API calls should use these instead of raw fetch()
 *
 * MessagePack library loaded via CDN, available as window.MessagePack
 */

// Get MessagePack from global scope (loaded via CDN)
const msgpack = window.MessagePack || {};

// localStorage key for tracking API calls for session recovery
const API_CALLS_KEY = 'countymap_api_calls';

// API paths that should be tracked for recovery (data endpoints)
const TRACKED_API_PATTERNS = [
  '/api/earthquakes/',
  '/api/storms/',
  '/api/volcanoes/',
  '/api/wildfires/',
  '/api/tornadoes/',
  '/api/tsunamis/',
  '/api/floods/',
  '/api/climate/'
];

/**
 * Check if a URL should be tracked for session recovery.
 */
function shouldTrackCall(url) {
  return TRACKED_API_PATTERNS.some(pattern => url.includes(pattern));
}

/**
 * Log an API call to localStorage for session recovery.
 */
function logApiCall(url) {
  try {
    const calls = JSON.parse(localStorage.getItem(API_CALLS_KEY) || '[]');
    // Avoid duplicates
    if (!calls.includes(url)) {
      calls.push(url);
      localStorage.setItem(API_CALLS_KEY, JSON.stringify(calls));
    }
  } catch (e) {
    // localStorage not available
  }
}

/**
 * Get all logged API calls for session recovery.
 */
export function getApiCallsForRecovery() {
  try {
    return JSON.parse(localStorage.getItem(API_CALLS_KEY) || '[]');
  } catch (e) {
    return [];
  }
}

/**
 * Clear logged API calls (called by New Chat).
 */
export function clearApiCalls() {
  try {
    localStorage.removeItem(API_CALLS_KEY);
  } catch (e) {
    // Ignore
  }
}

/**
 * Fetch data from API endpoint with MessagePack decoding.
 * @param {string} url - API endpoint
 * @param {object} options - fetch options (optional)
 * @returns {Promise<any>} Decoded response data
 */
export async function fetchMsgpack(url, options = {}) {
  // Log data API calls for session recovery
  if (shouldTrackCall(url)) {
    logApiCall(url);
  }

  const response = await fetch(url, {
    ...options,
    headers: {
      'Accept': 'application/msgpack',
      ...options.headers,
    }
  });

  if (!response.ok) {
    let errorMsg = 'Request failed';
    try {
      const buffer = await response.arrayBuffer();
      const decoded = msgpack.decode(new Uint8Array(buffer));
      errorMsg = decoded.error || errorMsg;
    } catch (e) {
      errorMsg = response.statusText;
    }
    throw new Error(errorMsg);
  }

  const buffer = await response.arrayBuffer();
  return msgpack.decode(new Uint8Array(buffer));
}

/**
 * POST data to API endpoint with MessagePack encoding/decoding.
 * @param {string} url - API endpoint
 * @param {object} data - Data to send
 * @returns {Promise<any>} Decoded response data
 */
export async function postMsgpack(url, data) {
  return fetchMsgpack(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/msgpack',
    },
    body: msgpack.encode(data)
  });
}

/**
 * GET request with query params and MessagePack response.
 * @param {string} url - Base URL
 * @param {object} params - Query parameters
 * @returns {Promise<any>} Decoded response data
 */
export async function getMsgpack(url, params = {}) {
  const queryString = new URLSearchParams(params).toString();
  const fullUrl = queryString ? `${url}?${queryString}` : url;
  return fetchMsgpack(fullUrl);
}
